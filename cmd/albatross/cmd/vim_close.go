package cmd

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/albatross-org/go-albatross/entries"
	"github.com/spf13/cobra"
)

// VimCloseCmd represents the vim open command
var VimCloseCmd = &cobra.Command{
	Use:   "close",
	Short: "Take the path to a temporary file and makes the changes in the file.",
	Long:  `This command takes the path to a temporary file and makes the changes in the file.`,
	Run: func(cmd *cobra.Command, args []string) {
		encrypted, err := store.Encrypted()
		if err != nil {
			log.Fatal(err)
		} else if encrypted {
			fmt.Println("ERROR: It's not currently possible to use the Vim integration while the store is encrypted. This may change in a future version.")
			fmt.Println("\nTo allow access, run:")
			fmt.Println("    $ albatross decrypt")
			os.Exit(1)
		}

		path, err := cmd.Flags().GetString("path")
		checkArgVerbose(cmd, "path", err)

		if !strings.HasPrefix(path, filepath.Join(os.TempDir(), "vim-albatross")) {
			fmt.Println("ERROR: The path given is not to a temporary vim-albatross file.")
		}

		entryPath, dirPath := extractEntryPath(path)

		collection, err := store.Collection()
		if err != nil {
			fmt.Println("ERROR: Couldn't get the collection representation of the store.")
			fmt.Println(err)
			os.Exit(1)
		}

		filteredCollection, err := collection.Filter(entries.FilterPathsExact(entryPath))
		if err != nil {
			fmt.Println("ERROR: Couldn't filter the store for the path", path)
			fmt.Println(err)
			os.Exit(1)
		}

		list := filteredCollection.List().Slice()
		if len(list) == 0 {
			fmt.Println("ERROR: That entry doesn't exist.")
			os.Exit(1)
		}

		// Since paths are unique, the only item in this list should be the entry we're after.
		entry := list[0]

		contentBytes, err := ioutil.ReadFile(path)
		if err != nil {
			fmt.Println("ERROR: Couldn't read the supplied path.")
			os.Exit(1)
		}

		content := string(contentBytes)

		if entry.OriginalContents == content {
			fmt.Println("ERROR: No change made to entry:", entry.Path)
			os.Exit(1)
		}

		err = store.Update(entryPath, content)
		if err != nil {
			f, tempErr := ioutil.TempFile("", "albatross-recover")
			if tempErr != nil {
				fmt.Println("ERROR: Couldn't get create temporary file to save recovery entry to. You're on your own!")
				fmt.Println(err)
			}

			_, err = f.Write([]byte(content))
			if err != nil {
				fmt.Println("ERROR: Couldn't write to temporary file to save recovery entry to. You're on your own!")
				fmt.Println(err)
			}

			fmt.Println("ERROR: Couldn't update entry. A copy of the updated file has been saved to:", f.Name())
			fmt.Println(err)
			os.Exit(1)
		}

		// Sanity check we're not going to end up deleting something important.
		// This check is probably unneccesary.
		if !strings.HasPrefix(dirPath, filepath.Join(os.TempDir(), "vim-albatross")) {
			fmt.Println("ERROR: Supposedly going to delete path", dirPath, "rather than one starting with", filepath.Join(os.TempDir(), "vim-albatross"))
			os.Exit(1)
		}

		err = os.RemoveAll(dirPath)
		if err != nil {
			fmt.Println("ERROR: Couldn't clean up directory:", dirPath)
			fmt.Println(err)
			os.Exit(1)
		}
	},
}

// extractEntryPath turns paths to temporary entries into the path that's relative to the store.
// It turns something like:
//   /tmp/vim-albatross/P4ZUw7eiLpUuVyzb/school/physics/entry.md
// Into:
//   school/physics
// It returns the entry path along with the path to the random folder the entry is in.
func extractEntryPath(absolutePath string) (string, string) {
	temporaryPrefix := filepath.Join(os.TempDir(), "vim-albatross") + string(filepath.Separator)
	overallPath := strings.TrimPrefix(filepath.Dir(absolutePath), temporaryPrefix) // without the /tmp/vim-albatross/ part

	// The path now looks something like this:
	//   P4ZUw7eiLpUuVyzb/school/physics/entry.md
	// A 16 character random directory followed by a one character slash. Therefore we need to remove 17 characters.
	entryPath := overallPath[17:]
	randomDirPath := filepath.Join(temporaryPrefix, overallPath[:16])

	return entryPath, randomDirPath
}

func init() {
	VimCloseCmd.Flags().String("path", "", "path to temporary file generated by open command")

	VimCmd.AddCommand(VimCloseCmd)
}
